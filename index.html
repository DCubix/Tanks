<!DOCTYPE html>
<html>
	<head>
		<title>olcCodeJam</title>
	</head>
	<body>
		<style type="text/css">
			html, body { margin: 0; padding: 0; box-sizing: border-box; overflow: hidden; }
			#debug { background: white; padding: 10px; position:absolute; left: 10px; top: 10px; font-family: monospace; }
		</style>
		<canvas id="game" width="512" height="512">Error</canvas>
		<div id="debug"><pre><code id="debug_"></code></pre></div>
		<script type="text/javascript" src="engine/cannon.min.js"></script>
		<script type="text/javascript" src="engine/engine.js"></script>

		<script type="text/javascript">
			let dbg = document.getElementById("debug_");
			let zoom = 10.0;
			let ang = 0.0;
			let canvas = document.getElementById("game");
			gfx.create(canvas);
			input.create(canvas);

			engine.registerType("terrain", null, function(e, xform) {
				let obj = res.get("terrain.ply");
				gfx.draw(res.get("ground.png"), obj.vertices, obj.indices, xform);
			});

			engine.registerType("player", function(e, dt) {
				let dir = math.normalize(math.mul(e.rotation, [0.0, 0.0, 1.0, 0.0]));
				let moving = false;
				if (input.keyHeld("w")) {
					e.speed = 3.0;
					moving = true;
				} else if (input.keyHeld("s")) {
					e.speed = -3.0;
					moving = true;
				} else {
					e.speed = 0.0;
				}

				e.physicsBody.position.x += dir[0] * dt * e.vel;
				e.physicsBody.position.z += dir[2] * dt * e.vel;
				e.vel = math.lerp(e.vel, e.speed, 0.5);

				if (moving) {
					if (input.keyHeld("a")) {
						e.rot += dt * 1.5;
					} else if (input.keyHeld("d")) {
						e.rot -= dt * 1.5;
					}
					e.physicsBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), e.rot);
				}
			});

			engine.registerType("tank", null, function(e, xform) {
				let obj = res.get("tank.ply");
				let plane = res.get("plane.ply");
				let shadow = res.get("shadow.png");

				let pos = e.physicsBody.position;
				let shadPos = math.translation(pos.x, 0.05, pos.z);
				shadPos = math.mul(shadPos, math.scale(1.5, 1.5, 1.5));

				gfx.enableBlending();
				gfx.blendFunction(gfx.GL().DST_COLOR, gfx.GL().ONE_MINUS_SRC_ALPHA);
				gfx.draw(shadow, plane.vertices, plane.indices, shadPos);
				gfx.disableBlending();

				gfx.draw(res.get("tank.png"), obj.vertices, obj.indices, xform, e.color);
			});

			engine.create("ground", function(e) {
				let vs = res.get("terrain.ply").vertices.map(function(v) { return v[0]; });
				let is = res.get("terrain.ply").indices;
				let gs = new CANNON.Box(new CANNON.Vec3(30.0, 0.1, 30.0));
				e.physicsBody = new CANNON.Body({ mass: 0, shape: gs });
				engine.physics().addBody(e.physicsBody);

				e.types.push("physics", "terrain");
			});

			engine.create("tank", function(e) {
				e.physicsBody = new CANNON.Body({ mass: 1, shape: new CANNON.Box(new CANNON.Vec3(0.75, 0.16, 1.0)) });
				e.physicsBody.position.y = 1;
				engine.physics().addBody(e.physicsBody);
				e.types.push("physics", "tank", "player");

				e.color = [
					0.5 + Math.random() * 0.5,
					0.5 + Math.random() * 0.5,
					0.5 + Math.random() * 0.5,
					1.0
				];

				e.rot = 0.0;
				e.speed = 0.0;
				e.vel = 0.0;
			});

			res.add("tank.png", "texture");
			res.add("tank.ply", "model");
			res.add("ground.png", "texture");
			res.add("terrain.ply", "model");
			res.add("plane.ply", "model");
			res.add("shadow.png", "texture");
			res.load(function() {
				loop();
			});

			function loop() {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;

				engine.update();

				let tank = engine.get("tank");

				let loc = math.add([zoom, zoom, zoom], tank.position);
				let rot = math.lookAt([zoom, zoom, zoom], tank.position, [0, 1, 0]);
				dbg.innerHTML = `LOOK AT:
${math.matString(rot)}`;
				gfx.view(rot);

				let aspect = canvas.width / canvas.height;
				gfx.projection(math.perspective(math.radians(60.0), aspect, 0.001, 500.0));

				gfx.clear();
				engine.render();

				window.requestAnimationFrame(loop);
			}

		</script>
	</body>
</html>